{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This is a sample application that uses Django Rest Framework (DRF) to provide an API portal for a simple blog system, with a provision of synchronizing data with an external API.</p> <p>Resources:</p> <ul> <li>Quick Start Guide</li> <li>Architecture</li> <li>Developer Guide</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>The project is based on Django with Django REST Framework as the API platform.</p> <p>Background tasks execution (such as replication/push to JSON Placeholder API) is handled by Celery with celery-beat extension providing database-backed periodic tasks.</p> <p>OpenAPI-compliant API schema is generated using <code>drf_yasg</code> which also provides Swagger and Redoc UI for API inspection in browsers.</p> <p>Communication with external API (JSON Placeholder demo API) is handled by the <code>apiclient</code> package.</p>"},{"location":"architecture/#deployment","title":"Deployment","text":"<p>The project is packaged as a Docker compose stack, with main Django web server, Celery beat process, worker and Flower monitoring portal based on the same Docker image defined by a Dockerfile.</p> <p>The stack uses <code>nginx</code> as a reverse proxy and static files server.</p> <p>Caching and task queue brokerage is implemented on Redis platform.</p> <p>Production database is based on PostgreSQL.</p> <p>The stack exposes post 8000 for the main web server and port 5555 for the Flower monitor.</p>"},{"location":"architecture/#cicd","title":"CI/CD","text":"<p>CI/CD is based on GitHub workflow actions, with an automatic run of linters, basic tests, and documentation generation. The documentation generation system is based on MkDocs with <code>mkdocstrings</code> extension and will deploy results to GitHub pages.</p>"},{"location":"developer_guide/","title":"Developer Guide","text":""},{"location":"developer_guide/#overview","title":"Overview","text":"<p>The code is based on Python version 3.11 though it should work on any version higher that 3.8. The project is designed for development in a virtual environment. The requirements file is currently static and monolithic.</p> <p>In order to initialize the environment, run:</p> <pre><code>    python -m venv .venv\n    . .venv/bin/activate\n    python -m pip install -r src/requirements.txt\n    make run\n</code></pre> <p>This will bring up a development server on top of a SQLite database on port 8000 on local host.</p>"},{"location":"developer_guide/#linting","title":"Linting","text":"<p>Linting is provided by MegaLinter via a <code>pre-commit</code> hook.</p> <p>In order to check the whole codebase locally, run <code>make lint</code>.</p>"},{"location":"developer_guide/#testing","title":"Testing","text":"<p>Tests are based on <code>pytest</code> framework. In order to run all basic tests locally, run <code>make test</code> or just <code>pytest src/</code> This will execute pytest with a SQLite database and skip some tests due to its limitations.</p> <p>In order to run advanced tests (namely, API compliance checks based on <code>schemathesis</code>), the tests must be run on a Postgres database. Run <code>make test-live</code> to start such tests inside a local container stack.</p>"},{"location":"developer_guide/#automatic-documentation","title":"Automatic Documentation","text":"<p>The project uses MkDocs with <code>mkdocstrings</code> extension in order to generate the documentation automatically out of static Markdown files and inline documentation contained in the codebase. The default docstring format is Google.</p> <p>In order to rebuild the documentation and start a local documentation server, run <code>mkdocs serve</code></p>"},{"location":"quick_start/","title":"Quick Start Guide","text":""},{"location":"quick_start/#pre-requisites","title":"Pre-requisites","text":"<p>A modern Linux system with a running Docker, <code>docker-compose</code>, GNU <code>make</code> and <code>git</code>. Some testing has been done on <code>podman</code> but it is known to have issues.</p>"},{"location":"quick_start/#starting-services-and-initial-import","title":"Starting Services and Initial Import","text":"<p>Run <code>make</code> from the top directory. This will bring up a Docker stack with an app server listening on http://127.0.0.1:8000. The stack will be running in the foreground. For a background run, use <code>make bg</code> command, and when done with it, bring it down with <code>make dc-down</code>.</p>"},{"location":"quick_start/#initial-import-via-admin-ui","title":"Initial Import via Admin UI","text":"<p>Open the URL above, click the Admin link, login as <code>admin</code> with password <code>admin</code>, then go to any fact model page (like Posts or Comments) and press IMPORT FROM JPH button. This will start a foreground import job. When the import is finished, you will see some records imported from the fake API.</p>"},{"location":"quick_start/#initial-import-via-command-line","title":"Initial Import via Command Line","text":"<p>The initial import can alternatively be run from command line in a separate shell this way:</p> <p><code>make import</code></p>"},{"location":"quick_start/#replication","title":"Replication","text":"<p>The system is configured by default to start a full replication (push) job of recently modified records to the JSON Placeholder API every 10 minutes. It also supports manual starting of full and partial replication.</p>"},{"location":"quick_start/#full-periodic-push","title":"Full Periodic Push","text":"<p>The system is configured by default to start a full replication (push) job of recently modified records to the JSON Placeholder API every 10 minutes. The job is started in background, using Celery async task queue.</p> <p>After 10 minutes or so you will notice a record in the SyncLog model indicating that the initial push has completed. In case all components are functioning properly, the records will have <code>success</code> flag set and <code>end date</code> field filled in. The count field should indicate around 600 records, because the initial sync pushes all records to the slave system.</p> <p>If you modify at least one of the fact records (Post, Comment) and save them, the changes will be pushed at the next run of the replication job. Some 10 minutes later you will notice another <code>SyncLog</code> record, with <code>count</code> field equal to the number of records you've modified.</p>"},{"location":"quick_start/#full-manual-push","title":"Full Manual Push","text":"<p>You can also start the push task manually by running it as an admin action. This can be done by opening Periodic Tasks page in the admin, then ticking the checkbox next to the Full push to JSON Placeholder API task, selecting Run selected tasks from the Action dropdown above the task list, and pressing the Go button next to the dropdown.</p>"},{"location":"quick_start/#partial-push-of-selected-records","title":"Partial Push of Selected Records","text":"<p>Fact models (Posts, Comments) also provide an ability to push a number of manually selected records via an admin action. In order to do that, open the list of desired fact objects in the admin, tick checkboxes next to the records you wish to push, select Push selected records to JSON Placeholder API from the Action dropdown above, and press the Go button next to the dropdown.</p> <p>Partial push action is performed in the foreground, and the UI will be blocked until it is complete.</p>"},{"location":"quick_start/#restful-api","title":"RESTful API","text":"<p>The system also acts as a RESTful API server exposing endpoints for accessing and manipulating data.</p> <p>A built-in documentation and API browsing system should be available at http://0.0.0.0:8000/blog/</p> <p>The API accepts regular session authentication with username/password as well as bearer token authentication.</p>"},{"location":"quick_start/#bearer-token-authentication","title":"Bearer Token Authentication","text":"<p>Token can be generated via the admin interface by opening the Tokens model page, and pressing ADD TOKEN. The user ID on the next page needs to be filled in manually. You can use value <code>1</code> for the default superuser created during system initialization.</p> <p>Once the token object is saved, you will see a hexadecimal string generated by the system as its <code>KEY</code> value. That string can be used in the <code>Authorization</code> header in order to access the API endpoints as the corresponding user.</p> <p>The token can also be generated via a management command that can be run inside Docker stack this way:</p> <p><code>make cmd cmd='drf_create_token admin'</code></p> <p>The token authentication can be tested on command line by issuing the following <code>curl</code> command:</p> <pre><code>    curl -H 'Authorization: Bearer &lt;TOKEN&gt;' http://localhost:8000/blog/post/1/\n</code></pre> <p>where <code>&lt;TOKEN&gt;</code> should be substituted with the key obtained before. If successful, that command should output a JSON record similar to the one below:</p> <pre><code>    {\"id\":1,\"created_date\":\"2024-02-28T19:25:48.727313Z\",\"modified_date\":\"2024-02-28T19:25:48.727343Z\",\"user_id\":1,\"title\":\"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\"body\":\"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"}    \n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>blog<ul> <li>abstract_models</li> <li>admin</li> <li>authentication</li> <li>base_views</li> <li>management<ul> <li>commands<ul> <li>import_jph</li> </ul> </li> </ul> </li> <li>mixins<ul> <li>jsonplaceholder</li> </ul> </li> <li>models</li> <li>serializers</li> <li>tasks</li> <li>views</li> </ul> </li> <li>jsonplaceholder<ul> <li>client</li> </ul> </li> </ul>"},{"location":"reference/blog/","title":"blog","text":"<p>Blog project - main module.</p> <p>This module provides an API system for a simple blog application.</p> <p>Required Python version is 3.8+.</p>"},{"location":"reference/blog/abstract_models/","title":"abstract_models","text":"<p>Abstract model classes for the Blog project.</p>"},{"location":"reference/blog/abstract_models/#blog.abstract_models.TimeStampedModel","title":"<code>TimeStampedModel</code>","text":"<p>             Bases: <code>Model</code></p> <p>Create a model that will keep creation and modification time stamps .</p> Source code in <code>src/blog/abstract_models.py</code> <pre><code>class TimeStampedModel(models.Model):\n    \"\"\"\n    Create a model that will keep creation and modification time stamps .\n    \"\"\"\n\n    created_date = models.DateTimeField(auto_now_add=True)\n    modified_date = models.DateTimeField(auto_now=True)\n\n    class Meta:\n        abstract = True\n</code></pre>"},{"location":"reference/blog/admin/","title":"admin","text":"<p>Module providing admin UI for the Blog app.</p>"},{"location":"reference/blog/admin/#blog.admin.CommentAdmin","title":"<code>CommentAdmin</code>","text":"<p>             Bases: <code>SyncableAdminMixin</code>, <code>ModelAdmin</code></p> <p>Blog post comment model admin configuration.</p> Source code in <code>src/blog/admin.py</code> <pre><code>@admin.register(Comment)\nclass CommentAdmin(SyncableAdminMixin, admin.ModelAdmin):\n    \"\"\"Blog post comment model admin configuration.\"\"\"\n\n    list_display = (\"id\", \"post\", \"name\", \"email\", \"created_date\", \"body\")\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.PostAdmin","title":"<code>PostAdmin</code>","text":"<p>             Bases: <code>SyncableAdminMixin</code>, <code>ModelAdmin</code></p> <p>Blog post model admin configuration.</p> Source code in <code>src/blog/admin.py</code> <pre><code>@admin.register(Post)\nclass PostAdmin(SyncableAdminMixin, admin.ModelAdmin):\n    \"\"\"Blog post model admin configuration.\"\"\"\n\n    list_display = (\"id\", \"user_id\", \"title\", \"created_date\")\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.SyncLogAdmin","title":"<code>SyncLogAdmin</code>","text":"<p>             Bases: <code>ModelAdmin</code></p> <p>Sync log model admin configuration.</p> Source code in <code>src/blog/admin.py</code> <pre><code>@admin.register(SyncLog)\nclass SyncLogAdmin(admin.ModelAdmin):\n    \"\"\"Sync log model admin configuration.\"\"\"\n\n    list_display = (\n        \"id\",\n        \"created_date\",\n        \"end_date\",\n        \"success\",\n        \"record_count\",\n        \"result\",\n    )\n\n    @action(\n        label=\"Full push to JPH\",\n        description=\"Push all records to JSON Placeholder API\",\n    )\n    def push_all_to_jsonplaceholder(\n        self, request: HttpRequest, _obj: Any = None\n    ) -&gt; None:\n        \"\"\"Admin action to push all records to JSON Placeholder API.\"\"\"\n        push_to_jsonplaceholder.delay()\n        msg = \"Started full push in the background, watch the sync log for results.\"\n        self.message_user(\n            request,\n            msg,\n            messages.SUCCESS,\n        )\n\n    changelist_actions = (\"push_all_to_jsonplaceholder\",)\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.SyncLogAdmin.push_all_to_jsonplaceholder","title":"<code>push_all_to_jsonplaceholder(request, _obj=None)</code>","text":"<p>Admin action to push all records to JSON Placeholder API.</p> Source code in <code>src/blog/admin.py</code> <pre><code>@action(\n    label=\"Full push to JPH\",\n    description=\"Push all records to JSON Placeholder API\",\n)\ndef push_all_to_jsonplaceholder(\n    self, request: HttpRequest, _obj: Any = None\n) -&gt; None:\n    \"\"\"Admin action to push all records to JSON Placeholder API.\"\"\"\n    push_to_jsonplaceholder.delay()\n    msg = \"Started full push in the background, watch the sync log for results.\"\n    self.message_user(\n        request,\n        msg,\n        messages.SUCCESS,\n    )\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.SyncableAdminMixin","title":"<code>SyncableAdminMixin</code>","text":"<p>             Bases: <code>JSONPlaceholderImportMixin</code>, <code>JSONPlaceholderPushMixin</code>, <code>DjangoObjectActions</code>, <code>ModelAdmin</code></p> <p>A mixin for fact model admins providing import/push actions.</p> Source code in <code>src/blog/admin.py</code> <pre><code>class SyncableAdminMixin(\n    JSONPlaceholderImportMixin,\n    JSONPlaceholderPushMixin,\n    DjangoObjectActions,\n    admin.ModelAdmin,\n):\n    \"\"\"\n    A mixin for fact model admins providing import/push actions.\n    \"\"\"\n\n    @action(\n        label=\"Import from JPH\",\n        description=\"Import all records from JSON Placeholder API\",\n    )\n    def import_from_jsonplaceholder(\n        self, request: HttpRequest, _obj: Any = None\n    ) -&gt; None:\n        \"Admin action to import all records from JSON Placeholder API\"\n        try:\n            self.import_all()\n        except NotEmptyError as err:\n            self.message_user(\n                request, _(\"Failed to import: \") + str(err), messages.ERROR\n            )\n        else:\n            self.message_user(\n                request,\n                _(\"Import succeeded.\"),\n                messages.SUCCESS,\n            )\n\n    @takes_instance_or_queryset\n    @action(\n        label=\"Push to JPH\",\n        description=\"Push selected records to JSON Placeholder API\",\n    )\n    def push_to_jsonplaceholder(self, request: HttpRequest, queryset: QuerySet) -&gt; None:\n        \"Admin action to push selected records to JSON Placeholder API\"\n        if queryset:\n            result = self.push_by_queryset(queryset)\n            msg = _(\"Pushed %d recs, result: %s\") % (queryset.count(), result)\n\n            self.message_user(\n                request,\n                msg,\n                messages.SUCCESS,\n            )\n\n    changelist_actions = (\"import_from_jsonplaceholder\",)\n    change_actions = (\"import_from_jsonplaceholder\", \"push_to_jsonplaceholder\")\n    actions = (\"push_to_jsonplaceholder\",)\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.SyncableAdminMixin.import_from_jsonplaceholder","title":"<code>import_from_jsonplaceholder(request, _obj=None)</code>","text":"<p>Admin action to import all records from JSON Placeholder API</p> Source code in <code>src/blog/admin.py</code> <pre><code>@action(\n    label=\"Import from JPH\",\n    description=\"Import all records from JSON Placeholder API\",\n)\ndef import_from_jsonplaceholder(\n    self, request: HttpRequest, _obj: Any = None\n) -&gt; None:\n    \"Admin action to import all records from JSON Placeholder API\"\n    try:\n        self.import_all()\n    except NotEmptyError as err:\n        self.message_user(\n            request, _(\"Failed to import: \") + str(err), messages.ERROR\n        )\n    else:\n        self.message_user(\n            request,\n            _(\"Import succeeded.\"),\n            messages.SUCCESS,\n        )\n</code></pre>"},{"location":"reference/blog/admin/#blog.admin.SyncableAdminMixin.push_to_jsonplaceholder","title":"<code>push_to_jsonplaceholder(request, queryset)</code>","text":"<p>Admin action to push selected records to JSON Placeholder API</p> Source code in <code>src/blog/admin.py</code> <pre><code>@takes_instance_or_queryset\n@action(\n    label=\"Push to JPH\",\n    description=\"Push selected records to JSON Placeholder API\",\n)\ndef push_to_jsonplaceholder(self, request: HttpRequest, queryset: QuerySet) -&gt; None:\n    \"Admin action to push selected records to JSON Placeholder API\"\n    if queryset:\n        result = self.push_by_queryset(queryset)\n        msg = _(\"Pushed %d recs, result: %s\") % (queryset.count(), result)\n\n        self.message_user(\n            request,\n            msg,\n            messages.SUCCESS,\n        )\n</code></pre>"},{"location":"reference/blog/authentication/","title":"authentication","text":"<p>Custom auth classes for DRF.</p>"},{"location":"reference/blog/authentication/#blog.authentication.BearerAuthentication","title":"<code>BearerAuthentication</code>","text":"<p>             Bases: <code>TokenAuthentication</code></p> <p>Token auth class for DRF using Bearer header keyword.</p> Source code in <code>src/blog/authentication.py</code> <pre><code>class BearerAuthentication(authentication.TokenAuthentication):\n    \"\"\"Token auth class for DRF using Bearer header keyword.\"\"\"\n\n    keyword = \"Bearer\"\n</code></pre>"},{"location":"reference/blog/base_views/","title":"base_views","text":"<p>Base classes for Blog app views.</p>"},{"location":"reference/blog/base_views/#blog.base_views.BaseViewSet","title":"<code>BaseViewSet</code>","text":"<p>             Bases: <code>ModelViewSet</code></p> <p>Base view set class for the API.</p> <p>Provides workarounds for non-compliance of API schema generated by drf_yasg with OpenAPI specs.</p> Source code in <code>src/blog/base_views.py</code> <pre><code>@method_decorator(\n    name=\"list\", decorator=swagger_auto_schema(responses={404: \"Not found\"})\n)\n@method_decorator(\n    name=\"create\", decorator=swagger_auto_schema(responses={400: \"Bad request\"})\n)\n@method_decorator(\n    name=\"retrieve\", decorator=swagger_auto_schema(responses={404: \"Not found\"})\n)\n@method_decorator(\n    name=\"update\", decorator=swagger_auto_schema(responses={404: \"Not found\"})\n)\n@method_decorator(\n    name=\"partial_update\", decorator=swagger_auto_schema(responses={404: \"Not found\"})\n)\n@method_decorator(\n    name=\"destroy\", decorator=swagger_auto_schema(responses={404: \"Not found\"})\n)\nclass BaseViewSet(ModelViewSet):\n    \"\"\"\n    Base view set class for the API.\n\n    Provides workarounds for non-compliance of\n    API schema generated by drf_yasg with OpenAPI specs.\n    \"\"\"\n</code></pre>"},{"location":"reference/blog/models/","title":"models","text":"<p>Module providing core models for the Blog app.</p>"},{"location":"reference/blog/models/#blog.models.Comment","title":"<code>Comment</code>","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>Blog post comment model.</p> Source code in <code>src/blog/models.py</code> <pre><code>class Comment(TimeStampedModel):\n    \"\"\"Blog post comment model.\"\"\"\n\n    post = models.ForeignKey(\n        \"Post\",\n        on_delete=models.CASCADE,\n        help_text=\"The blog post for which the comment was made.\",\n    )\n    name = models.CharField(max_length=255, help_text=\"Commenter's name\")\n    email = models.EmailField(help_text=\"Commenter's email address\")\n    body = models.TextField(help_text=\"Full content of this comment\")\n\n    class Meta:\n        ordering = [\"pk\"]\n\n    def __str__(self) -&gt; str:\n        return f\"{self.name}&lt;{self.email}&gt;: {self.body!s:.80}\"\n</code></pre>"},{"location":"reference/blog/models/#blog.models.Post","title":"<code>Post</code>","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>Blog post model.</p> Source code in <code>src/blog/models.py</code> <pre><code>class Post(TimeStampedModel):\n    \"\"\"Blog post model.\"\"\"\n\n    # we should use a FK here\n    user_id = models.PositiveBigIntegerField(\n        \"User ID\",\n        default=settings.DEFAULT_USER_ID,\n        help_text=\"Original poster ID\",\n    )\n    title = models.CharField(\n        max_length=255, help_text=\"Short summary of this blog post\"\n    )\n    body = models.TextField(help_text=\"Full content of this blog post\")\n\n    class Meta:\n        ordering = [\"pk\"]\n\n    def __str__(self) -&gt; str:\n        return f\"{self.title}\"\n</code></pre>"},{"location":"reference/blog/models/#blog.models.SyncLog","title":"<code>SyncLog</code>","text":"<p>             Bases: <code>TimeStampedModel</code></p> <p>Sync log model.</p> <p>Keeps records of every sync (push) operation.</p> Source code in <code>src/blog/models.py</code> <pre><code>class SyncLog(TimeStampedModel):\n    \"\"\"\n    Sync log model.\n\n    Keeps records of every sync (push) operation.\n    \"\"\"\n\n    success = models.BooleanField(null=True, blank=True)\n    record_count = models.PositiveBigIntegerField(default=0)\n    end_date = models.DateTimeField(null=True, blank=True)\n    result = models.JSONField(null=True, blank=True)\n\n    class Meta:\n        ordering = [\"pk\"]\n</code></pre>"},{"location":"reference/blog/serializers/","title":"serializers","text":"<p>DRF serializers for the Blog app.</p>"},{"location":"reference/blog/serializers/#blog.serializers.BulkSavingSerializer","title":"<code>BulkSavingSerializer</code>","text":"<p>             Bases: <code>ListSerializer</code></p> <p>Serializer class that uses <code>bulk_create()</code> to optimize saving a batch of instances.</p> <p>Use it as a <code>Meta.list_serializer_class</code> in other serializers.</p> Source code in <code>src/blog/serializers.py</code> <pre><code>class BulkSavingSerializer(\n    serializers.ListSerializer\n):  # pylint: disable=abstract-method\n    \"\"\"\n    Serializer class that uses `bulk_create()` to optimize\n    saving a batch of instances.\n\n    Use it as a `Meta.list_serializer_class` in other serializers.\n    \"\"\"\n\n    MAX_BATCH_SIZE = 100\n    \"\"\"Size of the batch of instances for bulk creation.\"\"\"\n\n    def create(self, validated_data: dict) -&gt; Any:\n        if self.child:\n            model_class = getattr(self.child.Meta, \"model\")\n            instances = [model_class(**item) for item in validated_data]\n            return model_class.objects.bulk_create(\n                instances, batch_size=self.MAX_BATCH_SIZE\n            )\n        return None\n</code></pre>"},{"location":"reference/blog/serializers/#blog.serializers.BulkSavingSerializer.MAX_BATCH_SIZE","title":"<code>MAX_BATCH_SIZE = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Size of the batch of instances for bulk creation.</p>"},{"location":"reference/blog/serializers/#blog.serializers.CommentSerializer","title":"<code>CommentSerializer</code>","text":"<p>             Bases: <code>ModelSerializer</code></p> <p>Comment model serializer class.</p> Source code in <code>src/blog/serializers.py</code> <pre><code>class CommentSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Comment model serializer class.\n    \"\"\"\n\n    class Meta:\n        model = Comment\n        fields = \"__all__\"\n</code></pre>"},{"location":"reference/blog/serializers/#blog.serializers.JPHCommentSerializer","title":"<code>JPHCommentSerializer</code>","text":"<p>             Bases: <code>CommentSerializer</code></p> <p>Comment model serializer class with JSON Placeholder API format support.</p> Source code in <code>src/blog/serializers.py</code> <pre><code>class JPHCommentSerializer(CommentSerializer):\n    \"\"\"\n    Comment model serializer class with JSON Placeholder API format support.\n    \"\"\"\n\n    id = serializers.IntegerField()\n    postId = serializers.PrimaryKeyRelatedField(\n        source=\"post\", queryset=Post.objects.all()\n    )\n\n    class Meta:\n        model = Comment\n        exclude = [\"post\", \"created_date\", \"modified_date\"]\n        extra_kwargs = {\n            \"post\": {\"write_only\": True},\n        }\n        list_serializer_class = BulkSavingSerializer\n</code></pre>"},{"location":"reference/blog/serializers/#blog.serializers.JPHPostSerializer","title":"<code>JPHPostSerializer</code>","text":"<p>             Bases: <code>PostSerializer</code></p> <p>Post model serializer class with JSON Placeholder API format support.</p> Source code in <code>src/blog/serializers.py</code> <pre><code>class JPHPostSerializer(PostSerializer):\n    \"\"\"\n    Post model serializer class with JSON Placeholder API format support.\n    \"\"\"\n\n    id = serializers.IntegerField()\n    userId = serializers.IntegerField(source=\"user_id\")\n\n    class Meta:\n        model = Post\n        exclude = [\"created_date\", \"modified_date\"]\n        extra_kwargs = {\n            \"user_id\": {\"write_only\": True},\n        }\n        list_serializer_class = BulkSavingSerializer\n</code></pre>"},{"location":"reference/blog/serializers/#blog.serializers.PostSerializer","title":"<code>PostSerializer</code>","text":"<p>             Bases: <code>ModelSerializer</code></p> <p>Post model serializer class.</p> Source code in <code>src/blog/serializers.py</code> <pre><code>class PostSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Post model serializer class.\n    \"\"\"\n\n    class Meta:\n        model = Post\n        fields = \"__all__\"\n</code></pre>"},{"location":"reference/blog/tasks/","title":"tasks","text":"<p>Celery tasks for the Blog app .</p>"},{"location":"reference/blog/tasks/#blog.tasks.Pusher","title":"<code>Pusher</code>","text":"<p>             Bases: <code>JSONPlaceholderPushMixin</code></p> <p>JSON Placeholder API pusher class.</p> Source code in <code>src/blog/tasks.py</code> <pre><code>class Pusher(JSONPlaceholderPushMixin):\n    \"\"\"\n    JSON Placeholder API pusher class.\n    \"\"\"\n</code></pre>"},{"location":"reference/blog/tasks/#blog.tasks.push_to_jsonplaceholder","title":"<code>push_to_jsonplaceholder()</code>","text":"<p>Perform a full push to JSON Placeholder API.</p> Source code in <code>src/blog/tasks.py</code> <pre><code>@shared_task\ndef push_to_jsonplaceholder() -&gt; None:\n    \"\"\"\n    Perform a full push to JSON Placeholder API.\n    \"\"\"\n    log.info(\"Starting full push...\")\n    pusher = Pusher()\n    result = pusher.push_all()\n    log.info(\"Full push finished, result=%s\", result)\n</code></pre>"},{"location":"reference/blog/views/","title":"views","text":"<p>Module providing views for the Blog app.</p>"},{"location":"reference/blog/views/#blog.views.CommentModelViewSet","title":"<code>CommentModelViewSet</code>","text":"<p>             Bases: <code>BaseViewSet</code></p> <p>Comment to a blog post.</p> <p>Represents comments made by users to blog posts.</p> Source code in <code>src/blog/views.py</code> <pre><code>class CommentModelViewSet(BaseViewSet):\n    \"\"\"\n    Comment to a blog post.\n\n    Represents comments made by users to blog posts.\n    \"\"\"\n\n    serializer_class = CommentSerializer\n    queryset = Comment.objects.all()\n    pagination_class = PageNumberPagination\n</code></pre>"},{"location":"reference/blog/views/#blog.views.PostModelViewSet","title":"<code>PostModelViewSet</code>","text":"<p>             Bases: <code>BaseViewSet</code></p> <p>Blog post.</p> <p>Represents posts to the blog by users.</p> Source code in <code>src/blog/views.py</code> <pre><code>class PostModelViewSet(BaseViewSet):\n    \"\"\"\n    Blog post.\n\n    Represents posts to the blog by users.\n    \"\"\"\n\n    serializer_class = PostSerializer\n    queryset = Post.objects.all()\n    pagination_class = PageNumberPagination\n</code></pre>"},{"location":"reference/blog/views/#blog.views.index","title":"<code>index(request)</code>","text":"<p>The home page view.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>HttpRequest</code> <p>HTTP request causing this call</p> required <p>Returns:</p> Name Type Description <code>HttpResponse</code> <code>HttpResponse</code> <p>response data with home page rendered.</p> Source code in <code>src/blog/views.py</code> <pre><code>def index(request: HttpRequest) -&gt; HttpResponse:\n    \"\"\"\n    The home page view.\n\n    Args:\n        request (HttpRequest): HTTP request causing this call\n\n    Returns:\n        HttpResponse: response data with home page rendered.\n    \"\"\"\n    return render(request, \"index.djhtml\")\n</code></pre>"},{"location":"reference/blog/management/","title":"management","text":""},{"location":"reference/blog/management/commands/","title":"commands","text":""},{"location":"reference/blog/management/commands/import_jph/","title":"import_jph","text":"<p>Management command module for importing data.</p>"},{"location":"reference/blog/management/commands/import_jph/#blog.management.commands.import_jph.Command","title":"<code>Command</code>","text":"<p>             Bases: <code>JSONPlaceholderImportMixin</code>, <code>BaseCommand</code></p> <p>Management command class for importing data.</p> <p>Imports all data from JSON placeholder API into local DB.</p> <p>Raises:</p> Type Description <code>CommandError</code> <p>if DB tables not empty</p> Source code in <code>src/blog/management/commands/import_jph.py</code> <pre><code>class Command(JSONPlaceholderImportMixin, BaseCommand):\n    \"\"\"\n    Management command class for importing data.\n\n    Imports all data from JSON placeholder API into local DB.\n\n    Raises:\n        CommandError: if DB tables not empty\n    \"\"\"\n\n    help = \"\"\"\n    Imports data from JSON placeholder API.\n    \"\"\"\n\n    def handle(self, *args: Any, **options: Any) -&gt; None:\n        try:\n            self.import_all()\n        except NotEmptyError as err:\n            raise CommandError(str(err)) from err\n</code></pre>"},{"location":"reference/blog/mixins/","title":"mixins","text":""},{"location":"reference/blog/mixins/jsonplaceholder/","title":"jsonplaceholder","text":"<p>Module containing mixins for using JSON Placeholder API in a DRF project.</p>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderAdapterMixin","title":"<code>JSONPlaceholderAdapterMixin</code>","text":"<p>A base mixin for JSONPlaceholder API support.</p> <p>Provides an API client instance.</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>class JSONPlaceholderAdapterMixin:  # pylint: disable=too-few-public-methods\n    \"\"\"\n    A base mixin for JSONPlaceholder API support.\n\n    Provides an API client instance.\n    \"\"\"\n\n    # Must be sorted in dependency order.\n    ENDPOINTS = {\n        \"post\": EndPoint(Post, JPHPostSerializer),\n        \"comment\": EndPoint(Comment, JPHCommentSerializer),\n    }\n\n    def __init__(self, *args: Any, **kw: Any) -&gt; None:\n        super().__init__(*args, **kw)\n        self._client: JSONPlaceholderClient | None = None\n\n    @property\n    def client(self) -&gt; JSONPlaceholderClient:\n        \"\"\"\n        Return a JSON placeholder API client instance.\n\n        Returns:\n            JSONPlaceholderClient: client instance.\n        \"\"\"\n        if self._client is None:\n            self._client = JSONPlaceholderClient()\n        return self._client\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderAdapterMixin.client","title":"<code>client: JSONPlaceholderClient</code>  <code>property</code>","text":"<p>Return a JSON placeholder API client instance.</p> <p>Returns:</p> Name Type Description <code>JSONPlaceholderClient</code> <code>JSONPlaceholderClient</code> <p>client instance.</p>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderImportMixin","title":"<code>JSONPlaceholderImportMixin</code>","text":"<p>             Bases: <code>JSONPlaceholderAdapterMixin</code></p> <p>A mixin class providing functionality to import data from JSON Placeholder API.</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>class JSONPlaceholderImportMixin(JSONPlaceholderAdapterMixin):\n    \"\"\"\n    A mixin class providing functionality to import data\n    from JSON Placeholder API.\n    \"\"\"\n\n    MAX_BATCH_SIZE = 100\n\n    def check_import_possible(self) -&gt; None:\n        \"\"\"\n        Check if importing data is possible at this point.\n\n        Raises an exception if import is not possible.\n\n        Raises:\n            NotEmptyError: relevant DB tables are not empty\n        \"\"\"\n        if any(ep.model.objects.count() for ep in self.ENDPOINTS.values()):\n            raise NotEmptyError\n\n    def import_resource(self, endpoint: str) -&gt; None:\n        \"\"\"\n        Import all records from a single resource endpoint.\n\n        Args:\n            endpoint (str): endpoint name\n        \"\"\"\n        resource = self.ENDPOINTS[endpoint]\n        serializer = resource.serializer_class(\n            data=self.client.get_all(endpoint), many=True\n        )\n        # improve robustness: if validation fails, import valid records only\n        serializer.is_valid(raise_exception=True)\n        serializer.save()\n\n    def import_all(self) -&gt; None:\n        \"\"\"\n        Do a full import.\n\n        Import all records from all known endpoints, if possible.\n        Otherwise, raise an exception.\n        \"\"\"\n        self.check_import_possible()\n        with transaction.atomic():\n            for endpoint in self.ENDPOINTS:\n                self.import_resource(endpoint)\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderImportMixin.check_import_possible","title":"<code>check_import_possible()</code>","text":"<p>Check if importing data is possible at this point.</p> <p>Raises an exception if import is not possible.</p> <p>Raises:</p> Type Description <code>NotEmptyError</code> <p>relevant DB tables are not empty</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def check_import_possible(self) -&gt; None:\n    \"\"\"\n    Check if importing data is possible at this point.\n\n    Raises an exception if import is not possible.\n\n    Raises:\n        NotEmptyError: relevant DB tables are not empty\n    \"\"\"\n    if any(ep.model.objects.count() for ep in self.ENDPOINTS.values()):\n        raise NotEmptyError\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderImportMixin.import_all","title":"<code>import_all()</code>","text":"<p>Do a full import.</p> <p>Import all records from all known endpoints, if possible. Otherwise, raise an exception.</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def import_all(self) -&gt; None:\n    \"\"\"\n    Do a full import.\n\n    Import all records from all known endpoints, if possible.\n    Otherwise, raise an exception.\n    \"\"\"\n    self.check_import_possible()\n    with transaction.atomic():\n        for endpoint in self.ENDPOINTS:\n            self.import_resource(endpoint)\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderImportMixin.import_resource","title":"<code>import_resource(endpoint)</code>","text":"<p>Import all records from a single resource endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint name</p> required Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def import_resource(self, endpoint: str) -&gt; None:\n    \"\"\"\n    Import all records from a single resource endpoint.\n\n    Args:\n        endpoint (str): endpoint name\n    \"\"\"\n    resource = self.ENDPOINTS[endpoint]\n    serializer = resource.serializer_class(\n        data=self.client.get_all(endpoint), many=True\n    )\n    # improve robustness: if validation fails, import valid records only\n    serializer.is_valid(raise_exception=True)\n    serializer.save()\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin","title":"<code>JSONPlaceholderPushMixin</code>","text":"<p>             Bases: <code>JSONPlaceholderAdapterMixin</code></p> <p>A mixin supporting pushing to JSON Placeholder API.</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>class JSONPlaceholderPushMixin(JSONPlaceholderAdapterMixin):\n    \"\"\"\n    A mixin supporting pushing to JSON Placeholder API.\n    \"\"\"\n\n    @property\n    def last_sync_date(self) -&gt; datetime.datetime | None:\n        \"\"\"\n        Timestamp if last successful sync (push).\n\n        Returns:\n            datetime.datetime | None: last sync timestamp or `None` if none found\n        \"\"\"\n        last_sync = (\n            SyncLog.objects.filter(success=True, end_date__isnull=False)\n            .order_by(\"created_date\")\n            .last()\n        )\n        return last_sync.created_date if last_sync else None\n\n    def push_by_queryset(self, queryset: QuerySetAny) -&gt; Dict[str, Any]:\n        \"\"\"\n        Push records from a given queryset.\n\n        Infers API model name from queryset model, then pushes records to the\n        matching endpoint.\n\n        Args:\n            queryset (QuerySetAny): source queryset with instances to be pushed\n\n        Returns:\n            Dict[str, Any]: summary report with pushed record count and error messages\n        \"\"\"\n        endpoint = [\n            name for name, ep in self.ENDPOINTS.items() if ep.model is queryset.model\n        ][0]\n        return self.push_resource(endpoint, queryset)\n\n    def push_by_endpoint(self, endpoint: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Push all records from a model to the corresponding remote API endpoint.\n\n        Args:\n            endpoint (str): endpoint name to push to\n\n        Returns:\n            Dict[str, Any]: summary report with pushed record count and error messages\n        \"\"\"\n        resource = self.ENDPOINTS[endpoint]\n        queryset = resource.model.objects.all()\n        return self.push_resource(endpoint, queryset)\n\n    def push_resource(self, endpoint: str, queryset: QuerySetAny) -&gt; Dict[str, Any]:\n        \"\"\"\n        Push records from a given queryset to the specified endpoint.\n\n        Checks if there was a successful sync before,\n        abd if yes, selects only records modified after that sync,\n        otherwise selects all records.\n        After that the method locks selected records, serializes them,\n        and pushes one-by-one to the given endpoint, checking for\n        errors in the process and collecting operations report.\n\n        Args:\n            endpoint (str): endpoint name to push to\n            queryset (QuerySetAny): source queryset with records to push\n\n        Returns:\n            Dict[str, Any]: summary report with pushed record count and error messages\n        \"\"\"\n        resource = self.ENDPOINTS[endpoint]\n        count = 0\n        errors = []\n        with transaction.atomic():\n            if self.last_sync_date:\n                queryset = queryset.filter(modified_date__gte=self.last_sync_date)\n            queryset = queryset.select_for_update()  # lock records\n            serializer = resource.serializer_class(queryset, many=True)\n\n            for obj in serializer.data:\n                try:\n                    log.debug(\"Pushing to %s: %s\", endpoint, obj)\n                    self.client.put_one(endpoint, obj)\n                except APIClientError as err:\n                    errors.append({\"obj\": obj, \"message\": str(err)})\n                else:\n                    count += 1  # type: ignore\n        return {\"count\": count, \"errors\": errors}\n\n    def push_all(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Push all relevant records from all endpoints.\n\n        Creates a sync log record, iterates over endpoints,\n        and pushes records from each of them, collecting\n        operations report.\n\n        Returns:\n            Dict[str, Any]: summary report with pushed record count and error messages\n        \"\"\"\n        log_record = SyncLog.objects.create()\n        result = {}\n        count = 0\n        for endpoint in self.ENDPOINTS:\n            result[endpoint] = self.push_by_endpoint(endpoint)\n            count += result[endpoint][\"count\"]\n        SyncLog.objects.filter(pk=log_record.pk).update(\n            end_date=timezone.now(), record_count=count, result=result, success=True\n        )\n        result[\"count\"] = count  # type: ignore\n        return result\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin.last_sync_date","title":"<code>last_sync_date: datetime.datetime | None</code>  <code>property</code>","text":"<p>Timestamp if last successful sync (push).</p> <p>Returns:</p> Type Description <code>datetime | None</code> <p>datetime.datetime | None: last sync timestamp or <code>None</code> if none found</p>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin.push_all","title":"<code>push_all()</code>","text":"<p>Push all relevant records from all endpoints.</p> <p>Creates a sync log record, iterates over endpoints, and pushes records from each of them, collecting operations report.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: summary report with pushed record count and error messages</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def push_all(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Push all relevant records from all endpoints.\n\n    Creates a sync log record, iterates over endpoints,\n    and pushes records from each of them, collecting\n    operations report.\n\n    Returns:\n        Dict[str, Any]: summary report with pushed record count and error messages\n    \"\"\"\n    log_record = SyncLog.objects.create()\n    result = {}\n    count = 0\n    for endpoint in self.ENDPOINTS:\n        result[endpoint] = self.push_by_endpoint(endpoint)\n        count += result[endpoint][\"count\"]\n    SyncLog.objects.filter(pk=log_record.pk).update(\n        end_date=timezone.now(), record_count=count, result=result, success=True\n    )\n    result[\"count\"] = count  # type: ignore\n    return result\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin.push_by_endpoint","title":"<code>push_by_endpoint(endpoint)</code>","text":"<p>Push all records from a model to the corresponding remote API endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint name to push to</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: summary report with pushed record count and error messages</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def push_by_endpoint(self, endpoint: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Push all records from a model to the corresponding remote API endpoint.\n\n    Args:\n        endpoint (str): endpoint name to push to\n\n    Returns:\n        Dict[str, Any]: summary report with pushed record count and error messages\n    \"\"\"\n    resource = self.ENDPOINTS[endpoint]\n    queryset = resource.model.objects.all()\n    return self.push_resource(endpoint, queryset)\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin.push_by_queryset","title":"<code>push_by_queryset(queryset)</code>","text":"<p>Push records from a given queryset.</p> <p>Infers API model name from queryset model, then pushes records to the matching endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>queryset</code> <code>QuerySetAny</code> <p>source queryset with instances to be pushed</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: summary report with pushed record count and error messages</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def push_by_queryset(self, queryset: QuerySetAny) -&gt; Dict[str, Any]:\n    \"\"\"\n    Push records from a given queryset.\n\n    Infers API model name from queryset model, then pushes records to the\n    matching endpoint.\n\n    Args:\n        queryset (QuerySetAny): source queryset with instances to be pushed\n\n    Returns:\n        Dict[str, Any]: summary report with pushed record count and error messages\n    \"\"\"\n    endpoint = [\n        name for name, ep in self.ENDPOINTS.items() if ep.model is queryset.model\n    ][0]\n    return self.push_resource(endpoint, queryset)\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.JSONPlaceholderPushMixin.push_resource","title":"<code>push_resource(endpoint, queryset)</code>","text":"<p>Push records from a given queryset to the specified endpoint.</p> <p>Checks if there was a successful sync before, abd if yes, selects only records modified after that sync, otherwise selects all records. After that the method locks selected records, serializes them, and pushes one-by-one to the given endpoint, checking for errors in the process and collecting operations report.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>endpoint name to push to</p> required <code>queryset</code> <code>QuerySetAny</code> <p>source queryset with records to push</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: summary report with pushed record count and error messages</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>def push_resource(self, endpoint: str, queryset: QuerySetAny) -&gt; Dict[str, Any]:\n    \"\"\"\n    Push records from a given queryset to the specified endpoint.\n\n    Checks if there was a successful sync before,\n    abd if yes, selects only records modified after that sync,\n    otherwise selects all records.\n    After that the method locks selected records, serializes them,\n    and pushes one-by-one to the given endpoint, checking for\n    errors in the process and collecting operations report.\n\n    Args:\n        endpoint (str): endpoint name to push to\n        queryset (QuerySetAny): source queryset with records to push\n\n    Returns:\n        Dict[str, Any]: summary report with pushed record count and error messages\n    \"\"\"\n    resource = self.ENDPOINTS[endpoint]\n    count = 0\n    errors = []\n    with transaction.atomic():\n        if self.last_sync_date:\n            queryset = queryset.filter(modified_date__gte=self.last_sync_date)\n        queryset = queryset.select_for_update()  # lock records\n        serializer = resource.serializer_class(queryset, many=True)\n\n        for obj in serializer.data:\n            try:\n                log.debug(\"Pushing to %s: %s\", endpoint, obj)\n                self.client.put_one(endpoint, obj)\n            except APIClientError as err:\n                errors.append({\"obj\": obj, \"message\": str(err)})\n            else:\n                count += 1  # type: ignore\n    return {\"count\": count, \"errors\": errors}\n</code></pre>"},{"location":"reference/blog/mixins/jsonplaceholder/#blog.mixins.jsonplaceholder.NotEmptyError","title":"<code>NotEmptyError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>An Exception raised when DB already contains records in tables to be filled during import.</p> Source code in <code>src/blog/mixins/jsonplaceholder.py</code> <pre><code>class NotEmptyError(Exception):\n    \"\"\"\n    An Exception raised when DB already contains records\n    in tables to be filled during import.\n    \"\"\"\n\n    def __str__(self) -&gt; str:\n        return \"Database tables not empty, refusing import.\"\n</code></pre>"},{"location":"reference/jsonplaceholder/","title":"jsonplaceholder","text":"<p>JSON Placeholder Demo API client module.</p>"},{"location":"reference/jsonplaceholder/client/","title":"client","text":"<p>JSON Placeholder demo API client module.</p>"},{"location":"reference/jsonplaceholder/client/#jsonplaceholder.client.Endpoint","title":"<code>Endpoint</code>","text":"<p>Endpoint class.</p> <p>Collects all known endpoint paths.</p> Source code in <code>src/jsonplaceholder/client.py</code> <pre><code>@endpoint(base_url=\"https://jsonplaceholder.typicode.com\")\nclass Endpoint:  # pylint: disable=too-few-public-methods\n    \"\"\"\n    Endpoint class.\n\n    Collects all known endpoint paths.\n    \"\"\"\n\n    posts = \"posts\"\n    post = \"posts/{id}\"\n    comments = \"comments\"\n    comment = \"comments/{id}\"\n</code></pre>"},{"location":"reference/jsonplaceholder/client/#jsonplaceholder.client.JSONPlaceholderClient","title":"<code>JSONPlaceholderClient</code>","text":"<p>             Bases: <code>APIClient</code></p> <p>JSON Placeholder demo API client.</p> Source code in <code>src/jsonplaceholder/client.py</code> <pre><code>class JSONPlaceholderClient(APIClient):\n    \"\"\"\n    JSON Placeholder demo API client.\n    \"\"\"\n\n    def __init__(self, *args: Any, **kw: Any) -&gt; None:\n        super().__init__(\n            *args,\n            **kw\n            | {\n                \"response_handler\": JsonResponseHandler,\n                \"request_formatter\": JsonRequestFormatter,\n            }\n        )\n\n    @retry_request\n    def get_one(self, model: str, oid: int) -&gt; Any:\n        \"\"\"\n        Fetch one model object by OID\n\n        Args:\n            model (str): model name\n            oid (int): object ID\n\n        Returns:\n            response data with object details\n        \"\"\"\n        url = getattr(Endpoint, model).format(id=oid)\n        return self.get(url)\n\n    @retry_request\n    def get_all(self, model: str) -&gt; Any:\n        \"\"\"\n        Get all model objects.\n\n        Args:\n            model (str): model name\n\n        Returns:\n             response data with objects\n        \"\"\"\n        return self.get(getattr(Endpoint, model + \"s\"))\n\n    def put_one(self, model: str, data: dict) -&gt; Any:\n        \"\"\"\n        Update or create one object.\n\n        Args:\n            model (str): model name\n            data (dict): data to update/create an object with\n\n        Returns:\n            response data\n        \"\"\"\n        oid = data[\"id\"]\n        url = getattr(Endpoint, model).format(id=oid)\n        return self.put(url, data)\n</code></pre>"},{"location":"reference/jsonplaceholder/client/#jsonplaceholder.client.JSONPlaceholderClient.get_all","title":"<code>get_all(model)</code>","text":"<p>Get all model objects.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>model name</p> required <p>Returns:</p> Type Description <code>Any</code> <p>response data with objects</p> Source code in <code>src/jsonplaceholder/client.py</code> <pre><code>@retry_request\ndef get_all(self, model: str) -&gt; Any:\n    \"\"\"\n    Get all model objects.\n\n    Args:\n        model (str): model name\n\n    Returns:\n         response data with objects\n    \"\"\"\n    return self.get(getattr(Endpoint, model + \"s\"))\n</code></pre>"},{"location":"reference/jsonplaceholder/client/#jsonplaceholder.client.JSONPlaceholderClient.get_one","title":"<code>get_one(model, oid)</code>","text":"<p>Fetch one model object by OID</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>model name</p> required <code>oid</code> <code>int</code> <p>object ID</p> required <p>Returns:</p> Type Description <code>Any</code> <p>response data with object details</p> Source code in <code>src/jsonplaceholder/client.py</code> <pre><code>@retry_request\ndef get_one(self, model: str, oid: int) -&gt; Any:\n    \"\"\"\n    Fetch one model object by OID\n\n    Args:\n        model (str): model name\n        oid (int): object ID\n\n    Returns:\n        response data with object details\n    \"\"\"\n    url = getattr(Endpoint, model).format(id=oid)\n    return self.get(url)\n</code></pre>"},{"location":"reference/jsonplaceholder/client/#jsonplaceholder.client.JSONPlaceholderClient.put_one","title":"<code>put_one(model, data)</code>","text":"<p>Update or create one object.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>str</code> <p>model name</p> required <code>data</code> <code>dict</code> <p>data to update/create an object with</p> required <p>Returns:</p> Type Description <code>Any</code> <p>response data</p> Source code in <code>src/jsonplaceholder/client.py</code> <pre><code>def put_one(self, model: str, data: dict) -&gt; Any:\n    \"\"\"\n    Update or create one object.\n\n    Args:\n        model (str): model name\n        data (dict): data to update/create an object with\n\n    Returns:\n        response data\n    \"\"\"\n    oid = data[\"id\"]\n    url = getattr(Endpoint, model).format(id=oid)\n    return self.put(url, data)\n</code></pre>"}]}